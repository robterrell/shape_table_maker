<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="UTF-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1.0" />
        <title>Canvas Drawing</title>
        <style>
            #drawingCanvas {
                border: 1px solid #000;
                cursor: crosshair;
                image-rendering: pixelated;
            }
        </style>
    </head>
    <body>
        <div style="position: absolute; top: 0px; right: 10px">
            <button id="saveDrawing" onclick="saveDrawing()">Save as...</button>
            <select id="loadSelect"></select>
        </div>
        <div style="display: grid; left: 0px; top: 20px">
            <button id="pencilBtn" style="left: 0px; width: 60px; height: 40px">
                <img
                    src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABwAAAAUCAQAAAA0V5VyAAAA8ElEQVR42tXRvyuEAQCA4Ud3yqEjhYRuonQp6brBZLNYnMGPpIy3G4jdTXfZTDJYhLvFIIa7wqSEC/f9N8ZL99113+jdn+n1DxqTExO5SVWBfRFLGnQlsO5PMUlx7ZtSlTdgFYBZh+58C9SdSghnNYGGNEDKmR8Xdi0YN+PejtamVQUC2wCcKEoBGFK1EcJqTRZW1qOyvlDWaMcmFDUU9EdhcXnvri0ShY268SKnpy3bCp/64Nww0RjHbvVGZzxbEValM+NTVmsZga9OjEsHaJYwjzV7RnQs40PBsrSsTSVvKnp01ZySJ3Wvyo4sdcd+AVHMR3iVEvg+AAAAAElFTkSuQmCC"
                    alt="Pencil"
                    border="0"
                />
            </button>
            <button id="lineBtn" style="left: 0px; width: 60px; height: 40px">
                <img
                    src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAA8AAAAPCAQAAACR313BAAAAJUlEQVR42mPAA7wZ0nBL+jNcBSrAAfyAkv7DQ9J/oCUxwRZ8kgBRfRSBbVWEfAAAAABJRU5ErkJggg=="
                    alt="Line"
                    border="0"
                />
            </button>
            <button id="rectBtn" style="left: 0px; width: 60px; height: 40px">
                <img
                    src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABIAAAARCAQAAAB6UzRyAAAAH0lEQVR42mNg+E8EJF4RHkCCopujiqiuiPJooVpSAQC7OnoJqmh4RQAAAABJRU5ErkJggg=="
                    alt="Rectangle"
                    border="0"
                />
            </button>
            <button id="ovalBtn" style="left: 0px; width: 60px; height: 40px">
                <img
                    src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABoAAAATCAQAAAAkTNWNAAABIklEQVR42p3NvyvmcQDA8ddzT3fndIOLG+4Ww12ZDAYDGSSFgTIoipHCoKSUQSZSiixIj/woKeqZRIpHPI/ioUxf389/YzDoSQ/fvMb38lYipdGodcfyHt04tW1Sm2/KqDDiXBAU7Fg1b1nGS7k1o9obTc4FWUP+KFWl25ZYUZ8SPSJXupTXICuYAqBVLKvG+75bFYwClfLyfvlY2oHIPxgUdEqmVmwedhWkJbWlKMWdFckNC/4SmZNcn6Duk6c9eWlJZRSlGBJ0SKbWkwWoVHCtysfS9kX+A21iR6q976tlwTgAvSI57cqrdySYluJVi5zgUL8apX7qtCH2YMAbP4y5FAQ5m5bMWbTmRCwomvVbGV80m5Bx5lbk3oV90zpUAADPDvpXd0migyQAAAAASUVORK5CYII="
                    alt="Oval"
                    border="0"
                />
            </button>
            <button id="zoomInBtn" style="left: 0px; width: 60px; height: 40px">
                <img
                    src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABMAAAATCAQAAADYWf5HAAABAklEQVR42o3OL0tDURjA4UfuQC4mRQzqndEgFpNRwa7gn2wzmCxqsWiw6NSZTYaxDzDYil4HS2NomIPzbTTIPbAx5hNOOb+X91XYUdXW1/FiX4lRC2r6Kg5s2XWtp2V1NPpQl4lmVX1Zg6imbhpEU+7kUuJNfRmAIyVAquNEoaoi6lsBcKqh0HY4JtsQzMSPbXBkYCD4fV2CsqAM0LEHEpnMt02ZFKwLZgFe3IxZeixX2NeLMy6kgETTuUJJy7Mpw850zROt+nQvFSXOBK8SiNbkOk5tKFt3rKkrFzwNh6kTDUEQ5M7NW/QmeJQYMSMzB/AXPkhMsORdUPlveGWiZS23Pzo1RYNSBLaAAAAAAElFTkSuQmCC"
                />
            </button>
            <button id="zoomOutBtn" style="left: 0px; width: 60px; height: 40px">
                <img
                    src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABMAAAATCAQAAADYWf5HAAAA7UlEQVR42o3KsUpCYQBA4S+uEJcmIxoqXRvCxScocC+woNHNwclFWlpqaCkrm50axAcQdKmb4CRSgwT3bWqIH/QK9p31CCo6xuYmuqpyZO3qmWs7d+zUjZmRw+z0oa9AkNfx5ciCnr5NizbcS8SCirmCrNhEXdDRtlrDQDB2YbWy1BbA3Am49B26AkWpIsDEGcgphGJQksoDdN1arSYRVM3kZUWGWoKckRcbljVN7SA49OlBTBBpSr2KLDiSmGgoKyqpGZpKpJ6Xx1jdQOo3iZYde96knkQythRsA/yNjyJr7HuXav93vLbWgZG7H0qYQP0ocnGnAAAAAElFTkSuQmCC"
                />
            </button>
            <button id="clear" style="left: 0px; width: 60px; height: 40px">
                <img
                    src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABMAAAAXCAQAAABDyLxRAAABF0lEQVR42pXQvyvEcRzH8QfuB9+vlD9AdoWSDBaTTAbFZOEPUAwWpSyKsikuZToZZZDhRsVydWXBlc1foO6uvieldN0nn27xfC3v4dXr9X6/CcyrevPyq7obI3pyZd8AYETFup7cWxY4t0Vg2UZHj05sdHXnsjtPcuhCXVmppyqelKxAn1cTerPrFICaWYwax4ApMA0OHEE/aEqxYBNjjsGZIaRasa2tKFDURqoJOcGWKQjkfCPRDGmtjq0oJhFKNSRRacEX3dJot1BalIFEI7JFaW2ILx1GFqfFl7bEaXkZ8nLi3YS08DV/S5PIVpAhQZzm0w4+7OHdEVI0AZhTkyJmSZVA3q0H5UjXnm1DYNCitUirZvyPHz0/YaPoSZd8AAAAAElFTkSuQmCC"
                />
            </button>
            <button id="fill" style="left: 0px; width: 60px; height: 40px">Fill</button>
        </div>

        <div style="position: absolute; top: 20px; left: 82px">
            <div style="display: grid">
                <canvas id="drawingCanvas" width="16" height="16" scale="1.0"></canvas>
                <div />
                <button id="convertBtn">Convert to String</button>
                <button id="makeShape">Convert to Shape</button>
                <button id="describeShape" onclick="describeShape()">Describe Shape</button>
                <button id="hexShape" onclick="hexDataForShape()">Hex Data for Shape</button>
                <button id="convertBasic" onclick="createBasic()">BASIC data</button>
                <button id="downloadShape" onclick="downloadShapeAsBinaryFile()">Download Shape</button><br />
                <button id="resize8" onclick="resizeCanvas(8);">8 x 8</button>
                <button id="resize16" onclick="resizeCanvas(16);">16 x 16</button>
                <button id="resize24" onclick="resizeCanvas(24);">24 x 24</button>
                <button id="resize32" onclick="resizeCanvas(32);">32 x 32</button>
                <button id="resize48" onclick="resizeCanvas(48);">48 x 48</button>
                <button id="resize64" onclick="resizeCanvas(64);">64 x 64</button>
            </div>
        </div>
        <div style="position: relative">
            <pre id="output" style="width: 600px"></pre>
        </div>

        <script>
            const canvas = document.getElementById("drawingCanvas");
            const ctx = canvas.getContext("2d");
            ctx.imageSmoothingEnabled = false;

            ctx.fillStyle = "rgb(255,255,255)";
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            let isDrawing = false;
            let startX = 0;
            let startY = 0;
            let tool = "pencil";
            let scale = 1;
            let scaledWidth = canvas.width;
            let scaledHeight = canvas.height;

            let originX = canvas.width / 2;
            let originY = canvas.height / 2;

            // Create an off-screen canvas for saving the drawing state
            let backupCanvas = document.createElement("canvas");
            let backupCtx = backupCanvas.getContext("2d");
            backupCanvas.width = canvas.width;
            backupCanvas.height = canvas.height;
            backupCtx.imageSmoothingEnabled = false;

            let outputCanvas = document.createElement("canvas");
            let outputCtx = backupCanvas.getContext("2d");
            outputCtx.imageSmoothingEnabled = false;
            outputCanvas.height = canvas.height;
            outputCanvas.width = canvas.width;

            clear();
            zoomIn();
            zoomIn();
            zoomIn();
            zoomIn();

            function resizeCanvas(w, h) {
                if (h == null) {
                    h = w;
                }
                canvas.width = w;
                canvas.height = h;
                outputCanvas.width = w;
                outputCanvas.height = h;
                backupCanvas.width = w;
                backupCanvas.height = h;
                updateCanvasScale();
                clear();
            }

            function startDrawing(e) {
                const [x, y] = adjustCoordinates(e);
                if (e.altKey) {
                    originX = x;
                    originY = y;
                    return;
                }
                saveCanvasState(canvas);
                isDrawing = true;
                startX = x;
                startY = y;
                // Get the image data for the pixel under the cursor
                const pixel = ctx.getImageData(x, y, 1, 1).data;
                // Check if the pixel is black (assuming full opacity for simplicity)
                const isBlack = pixel[0] === 0 || pixel[1] === 0 || pixel[2] === 0; // || pixel[3] === 0;

                //console.log("isBlack", isBlack, pixel[0], pixel[1], pixel[2]);
                if (tool === "pencil") {
                    // Set the drawing color based on the pixel color
                    ctx.fillStyle = isBlack ? "rgb(255,255,255)" : "rgb(0,0,0)";
                    ctx.fillRect(x, y, 1, 1);
                }

                if (tool === "fill") {
                    floodFill(x, y, "000");
                }
            }

            function draw(e) {
                if (!isDrawing) return;
                const [x, y] = adjustCoordinates(e);
                switch (tool) {
                    case "pencil":
                        ctx.fillRect(x, y, 1, 1);
                        break;
                    case "line":
                    case "rect":
                    case "oval":
                        redrawCanvas();
                        if (tool === "line") {
                            drawLineBresenham(ctx, startX, startY, x, y);
                        } else if (tool === "rect") {
                            drawLineBresenham(ctx, startX, startY, startX, y);
                            drawLineBresenham(ctx, startX, y, x, y);
                            drawLineBresenham(ctx, x, y, x, startY);
                            drawLineBresenham(ctx, startX, startY, x, startY);
                        } else if (tool === "oval") {
                            drawOvalAliased(ctx, startX, startY, x, y);
                        }
                        break;
                }
            }

            // Function to adjust mouse coordinates based on the zoom level
            function adjustCoordinates(e) {
                const rect = canvas.getBoundingClientRect();
                const x = Math.round((e.clientX - rect.left) / scale);
                const y = Math.round((e.clientY - rect.top) / scale);
                return [x, y];
            }

            function adjustCanvasForPixelArt(canvas) {
                // Determine the device's pixel ratio
                const pixelRatio = window.devicePixelRatio || 1;

                // Original CSS size of the canvas (could be set to your specific needs)
                const cssWidth = canvas.width;
                const cssHeight = canvas.height;

                // Adjust canvas size for high DPI display
                canvas.width = cssWidth * pixelRatio;
                canvas.height = cssHeight * pixelRatio;

                // Scale the context to compensate for the increased canvas size
                const ctx = canvas.getContext("2d");
                ctx.scale(pixelRatio, pixelRatio);

                // Optional: Disable image smoothing to ensure pixelated graphics
                ctx.imageSmoothingEnabled = false;
            }

            function endDrawing() {
                if (isDrawing) {
                    // When the drawing ends, save the current state to the backup canvas
                    backupCtx.clearRect(0, 0, backupCanvas.width, backupCanvas.height);
                    backupCtx.drawImage(canvas, 0, 0);
                }
                // plot the origin
                //ctx.fillStyle = "rgb(255,0,0)";
                //ctx.fillRect(originX, originY, 1, 1);
                isDrawing = false;
            }

            function redrawCanvas() {
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                // Restore the drawing from the backup canvas
                ctx.drawImage(backupCanvas, 0, 0);
            }

            function drawOvalAliased(ctx, startX, startY, x, y, color = "rgb(0,0,0)") {
                ctx.fillStyle = color;
                // Calculate the center of the oval
                const centerX = (startX + x) / 2;
                const centerY = (startY + y) / 2;

                // Calculate the radii of the oval
                const radiusX = Math.abs(x - startX) / 2;
                const radiusY = Math.abs(y - startY) / 2;

                let xPos, yPos;

                // Drawing the oval
                for (let angle = 0; angle < Math.PI * 2; angle += 0.01) {
                    xPos = centerX + radiusX * Math.cos(angle);
                    yPos = centerY + radiusY * Math.sin(angle);
                    ctx.fillRect(Math.round(xPos), Math.round(yPos), 1, 1);
                }
            }

            function zoomIn() {
                scale *= 2;
                updateCanvasScale();
            }

            function zoomOut() {
                scale /= 2;
                updateCanvasScale();
            }

            function updateCanvasScale() {
                scaledWidth = canvas.width * scale;
                scaledHeight = canvas.height * scale;
                canvas.style.width = `${scaledWidth}px`;
                canvas.style.height = `${scaledHeight}px`;
            }

            function clear() {
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                ctx.fillStyle = "rgba(255,255,255,255)";
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                backupCtx.clearRect(0, 0, canvas.width, canvas.height);
                backupCtx.fillStyle = "rgba(255,255,255,255)";
                backupCtx.fillRect(0, 0, canvas.width, canvas.height);
            }

            function drawLineBresenham(ctx, x0, y0, x1, y1, color = "rgb(0,0,0)") {
                ctx.fillStyle = color;
                let dx = Math.abs(x1 - x0),
                    sx = x0 < x1 ? 1 : -1;
                let dy = -Math.abs(y1 - y0),
                    sy = y0 < y1 ? 1 : -1;
                let err = dx + dy,
                    e2;

                while (true) {
                    ctx.fillRect(x0, y0, 1, 1); // Draw pixel at (x0, y0)
                    if (x0 === x1 && y0 === y1) break;
                    e2 = 2 * err;
                    if (e2 >= dy) {
                        err += dy;
                        x0 += sx;
                    }
                    if (e2 <= dx) {
                        err += dx;
                        y0 += sy;
                    }
                }
            }

            function convertCanvasToString() {
                outputCtx.drawImage(
                    canvas,
                    0,
                    0,
                    canvas.width,
                    canvas.height,
                    0,
                    0,
                    outputCanvas.width,
                    outputCanvas.height
                );

                const imageData = outputCtx.getImageData(0, 0, outputCanvas.width, outputCanvas.height);
                const pixels = imageData.data;
                const width = imageData.width;
                const height = imageData.height;
                let resultString = "";

                for (let y = 0; y < height; y++) {
                    for (let x = 0; x < width; x++) {
                        const index = (y * width + x) * 4; // Calculate index within the image data array
                        const r = pixels[index]; // red value of the pixel
                        const g = pixels[index + 1]; // green value of the pixel
                        const b = pixels[index + 2]; // blue value of the pixel
                        resultString += r == 0 ? "#" : "."; // Append '#' for drawn pixels and '.' for empty
                        //console.log(r, g, b);
                    }
                    resultString += "\n"; // New line at the end of each row
                }
                document.getElementById("output").textContent = resultString;
                return resultString;
            }

            function convertCanvasToShapeData() {
                const move_up = 0b000;
                const move_right = 0b001;
                const move_down = 0b010;
                const move_left = 0b011;
                const plot_up = 0b100;
                const plot_right = 0b101;
                const plot_down = 0b110;
                const plot_left = 0b111;

                const imageData = ctx.getImageData(0, 0, outputCanvas.width, outputCanvas.height);
                const pixels = imageData.data;
                const width = imageData.width;
                const height = imageData.height;
                let resultString = "";

                let commands = [];
                // TODO: error in the next line if the canvas isn't an even number of rows
                let y = 0;
                while (y < height) {
                    //if entire row is empty, skip
                    let rowIsEmpty = true;
                    for (let x = 0; x < width; x++) {
                        const index = (y * width + x) * 4; // Calculate index within the image data array
                        const r = pixels[index]; // red value of the pixel
                        if (r == 0) {
                            rowIsEmpty = false;
                        }
                    }
                    if (rowIsEmpty) {
                        console.log("row " + y + " is empty");
                        commands.push(move_down);
                        y = y + 1;
                        continue;
                    }
                    if (y >= height) break;

                    for (let x = 0; x < width; x++) {
                        const index = (y * width + x) * 4; // Calculate index within the image data array
                        const r = pixels[index]; // red value of the pixel
                        const endOfRow = x == width - 1;
                        if (r == 0) {
                            if (endOfRow) {
                                commands.push(plot_down);
                            } else {
                                commands.push(plot_right);
                            }
                        } else {
                            if (endOfRow) {
                                commands.push(move_down);
                            } else {
                                commands.push(move_right);
                            }
                        }
                        console.log(x, y, r, intToVectorName(commands[commands.length - 1]));
                    }

                    y = y + 1;
                    if (y >= height) break;

                    // next row, from right to left
                    for (let x = width - 1; x >= 0; x--) {
                        const index = (y * width + x) * 4; // Calculate index within the image data array
                        const r = pixels[index]; // red value of the pixel
                        const startOfRow = x == 0;
                        if (r == 0) {
                            if (startOfRow) {
                                commands.push(plot_down);
                            } else {
                                commands.push(plot_left);
                            }
                        } else {
                            if (startOfRow) {
                                commands.push(move_down);
                            } else {
                                commands.push(move_left);
                            }
                        }
                        console.log(x, y, r, intToVectorName(commands[commands.length - 1]));
                    }
                    y = y + 1;
                }
                commands.push(0);
                var out = chunk(commands, width + 2);
                document.getElementById("output").textContent = out.join("\n");
                return commands;
            }

            const chunk = (arr, size) =>
                Array.from({ length: Math.ceil(arr.length / size) }, (v, i) => arr.slice(i * size, i * size + size));

            function packCommands(commands) {
                // take an array of commands (ints 0-7) and pack them into the top and bottom of a byte
                // first three bits = first command, second three bits = second command
                // two high bits = left both zero
                var bytes = new Uint8Array(canvas.width * canvas.height + 6);
                bytes[0] = 1; // number of shapes
                bytes[1] = 0; // unused
                bytes[2] = 4; // offset to shape 1 (low order byte)
                bytes[3] = 0; // offset to shape 1 (high oder byte)
                // index 4 is the start of the shape data
                var index = 4;
                for (var i = 0; i < commands.length; i += 2) {
                    var c1 = commands[i];
                    // TODO: handle case where this gives an error
                    var c2 = commands[i + 1];
                    bytes[4 + i] = (c2 << 3) | c1;
                    console.log(c2, c1, bytes[4 + i]);
                }
                console.log(bytes);
                return bytes;
            }

            function packIntegersToUint8Array(integers) {
                // Calculate the size of the resulting Uint8Array
                // Each element needs 3 bits, so two elements make a byte.
                // If there's an odd number of integers, the last one still requires a full byte.
                // ignoring the special case of using the two high bits for now
                const size = Math.ceil(integers.length / 2) + 4;
                const packedArray = new Uint8Array(size);
                packedArray[0] = 1; // number of shapes
                packedArray[1] = 0; // unused
                packedArray[2] = 4; // offset to shape 1 (low order byte)
                packedArray[3] = 0; // offset to shape 1 (high oder byte)

                integers.forEach((value, index) => {
                    // Calculate which byte this value should go into
                    const byteIndex = 4 + Math.floor(index / 2);

                    if (value === 0) {
                        packedArray[byteIndex] = 0;
                        return;
                    }

                    // Ensure the value is within the expected range
                    if (value < 1 || value > 7) {
                        throw new RangeError("Integer values must be in the range of 1-7.");
                    }

                    if (index % 2 === 0) {
                        // If it's an even index (or the first of a pair),
                        // add the value to the byte without shifting (occupies the lowest 3 bits).
                        packedArray[byteIndex] = value;
                    } else {
                        // If it's an odd index (or the second of a pair),
                        // shift the value left by 3 bits and add it to the byte.
                        packedArray[byteIndex] |= value << 3;
                    }
                });

                return packedArray;
            }

            function createBasic() {
                let array = packIntegersToUint8Array(convertCanvasToShapeData());
                let result = "1000 REM SHAPE TABLE\n";
                result += "1010 DATA ";
                lineNum = 1010;
                array.forEach((byte, index) => {
                    // Convert byte to hex format, padded with a leading zero if necessary
                    //let val = byte.toString(16).padStart(2, "0").toUpperCase();
                    let val = byte.toString(10);
                    // Add the hex byte to the result string
                    result += val;
                    // Determine if a comma should be added
                    let isLastByteInLine = (index + 1) % 8 === 0;
                    let isLastByteInArray = index === array.length - 1;

                    // Add a comma if it's not the last byte in the line or the last byte in the array
                    if (!isLastByteInLine && !isLastByteInArray) {
                        result += ",";
                    }

                    // Add a newline after every 8 bytes, except after the last byte
                    if (isLastByteInLine && !isLastByteInArray) {
                        //let lineNum = 1020 + index * 10;
                        result += "\n" + ++lineNum + " DATA ";
                    }
                });
                result += "\n" + ++lineNum + " DATA -1";
                document.getElementById("output").textContent = result;
                return result;
            }

            function intToVectorName(i) {
                let result = "";
                switch (i) {
                    case 0:
                        result += "move up";
                        break;
                    case 1:
                        result += "move right";
                        break;
                    case 2:
                        result += "move down";
                        break;
                    case 3:
                        result += "move left";
                        break;
                    case 4:
                        result += "plot up";
                        break;
                    case 5:
                        result += "plot right";
                        break;
                    case 6:
                        result += "plot down";
                        break;
                    case 7:
                        result += "plot left";
                        break;
                }
                return result;
            }

            function describeShape() {
                let commands = convertCanvasToShapeData();
                let result = "";
                for (index in commands) {
                    let command = commands[index];
                    result += intToVectorName(command) + "\n";
                }
                document.getElementById("output").textContent = result;
                return result;
            }

            function hexDataForShape() {
                let commands = convertCanvasToShapeData();
                let result = "";
                for (index in commands) {
                    let command = commands[index];
                    result += command.toString(16).padStart(2, "0") + " ";
                }

                document.getElementById("output").textContent = result;
                return result;
            }

            function annotateShape() {
                let commands = convertCanvasToShapeData();
                let result = "";
                let temp = "";
                let i = 0;
                for (index in commands) {
                    let command = commands[index];
                    if (command == 2) {
                        i++;
                    }
                    result += i++ + intToVectorName(command) + "\n";
                }
                document.getElementById("output").textContent = result;
                return result;
            }

            let canvasStates = [];

            function saveCanvasState(canvas) {
                const dataUrl = canvas.toDataURL();
                canvasStates.push(dataUrl);
            }

            function undoCanvasState() {
                if (canvasStates.length <= 0) return;

                const previousState = canvasStates.pop();
                const img = new Image();
                img.onload = () => {
                    ctx.clearRect(0, 0, canvas.width, canvas.height);
                    ctx.drawImage(img, 0, 0, canvas.width, canvas.height);
                    backupCtx.clearRect(0, 0, backupCanvas.width, backupCanvas.height);
                    backupCtx.drawImage(img, 0, 0, backupCanvas.width, backupCanvas.height);
                };
                img.src = previousState;
            }

            function loadDrawingOntoCanvas(name) {
                let savedDataUrl = localStorage.getItem(name);
                if (savedDataUrl) {
                    let img = new Image();
                    img.src = savedDataUrl;
                    img.onload = function () {
                        // Display the image on the page or draw it on another canvas
                        clear();
                        ctx.drawImage(img, 0, 0, img.width, img.height);
                        backupCtx.drawImage(img, 0, 0, img.width, img.height);
                        canvasStates = [];
                    };
                }
            }

            function saveDrawing() {
                var name = prompt("Name to save as");
                if (name != null) {
                    saveDrawingToLocalStorage(name);
                }
            }

            function saveDrawingToLocalStorage(name) {
                const dataUrl = canvas.toDataURL();
                localStorage.setItem(name, dataUrl);
                showSelectMenuAndLoadDrawing();
            }

            function showSelectMenuAndLoadDrawing() {
                //const select = document.createElement('select');
                const select = document.getElementById("loadSelect");
                select.innerHTML = `<option>Load...</option>`;
                Object.keys(localStorage).forEach((key) => {
                    select.innerHTML += `<option value="${key}">${key}</option>`;
                });

                select.addEventListener("change", function () {
                    if (this.value !== "Load...") {
                        loadDrawingOntoCanvas(this.value);
                    }
                });
            }
            showSelectMenuAndLoadDrawing();

            function downloadShapeAsTextFile() {
                let filename = "";
                const select = document.getElementById("loadSelect");
                if (select.value == "Load...") {
                    filename = prompt("Save as...");
                    if (filename == null) return;
                } else {
                    filename = select.value;
                }
                filename += ".txt";

                const dataUrl = canvas.toDataURL();
                const blob = new Blob([dataUrl], { type: "text/plain" });

                // Create an object URL for the blob
                const url = URL.createObjectURL(blob);

                // Create a temporary anchor element and set its href to the blob URL
                const a = document.createElement("a");
                a.href = url;
                a.download = filename; // Set the filename for the download

                // Append the anchor to the document, trigger a click on it, and then remove it
                document.body.appendChild(a); // Append to the body (or any other existing element)
                a.click(); // Trigger the download

                // Clean up by revoking the object URL and removing the anchor element
                URL.revokeObjectURL(url);
                document.body.removeChild(a);
            }

            function downloadShapeAsBinaryFile() {
                let filename = "";
                const select = document.getElementById("loadSelect");
                if (select.value == "Load...") {
                    filename = prompt("Save as...");
                    if (filename == null) return;
                } else {
                    filename = select.value;
                    select.value = 0;
                }
                filename += ".bin";

                let data = convertCanvasToShapeData();
                let uint8Array = packIntegersToUint8Array(new Uint8Array(data));
                // Create a new Blob object using the Uint8Array's data
                const blob = new Blob([uint8Array], { type: "application/octet-stream" });

                // Create an object URL for the blob
                const url = URL.createObjectURL(blob);

                // Create a temporary anchor element and set its href to the blob URL
                const a = document.createElement("a");
                a.href = url;
                a.download = filename; // Set the filename for the download

                // Append the anchor to the document, trigger a click on it, and then remove it
                document.body.appendChild(a); // Append to the body (or any other existing element)
                a.click(); // Trigger the download

                // Clean up by revoking the object URL and removing the anchor element
                URL.revokeObjectURL(url);
                document.body.removeChild(a);
            }

            function floodFill(startX, startY, fillColor) {
                const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
                const data = imageData.data;
                const width = imageData.width;
                const targetColor = getColorAtPixel(data, startX, startY, width);
                const newColor = hexToRgba(fillColor);

                // Check if the target color is the same as the new color
                if (colorsMatch(targetColor, newColor)) {
                    return; // No need to fill
                }

                function fill(x, y) {
                    // Check bounds
                    if (x < 0 || y < 0 || x >= imageData.width || y >= imageData.height) {
                        return;
                    }

                    const currentColor = getColorAtPixel(data, x, y, width);

                    // If the current pixel's color is not the target color, or already the new color, return
                    if (!colorsMatch(currentColor, targetColor) || colorsMatch(currentColor, newColor)) {
                        return;
                    }

                    // Set the pixel to the new color
                    setColorAtPixel(data, x, y, newColor, width);

                    // Recursive calls for adjacent pixels
                    fill(x + 1, y); // East
                    fill(x - 1, y); // West
                    fill(x, y + 1); // South
                    fill(x, y - 1); // North
                }

                fill(startX, startY);

                ctx.putImageData(imageData, 0, 0);
            }

            // Helper functions
            function getColorAtPixel(data, x, y, width) {
                const index = (y * width + x) * 4;
                return {
                    r: data[index],
                    g: data[index + 1],
                    b: data[index + 2],
                    a: data[index + 3],
                };
            }

            function setColorAtPixel(data, x, y, color, width) {
                const index = (y * width + x) * 4;
                data[index] = color.r;
                data[index + 1] = color.g;
                data[index + 2] = color.b;
                data[index + 3] = color.a;
            }

            function hexToRgba(hex) {
                var r = 0,
                    g = 0,
                    b = 0,
                    a = 255; // Default is opaque black
                if (hex.length == 7) {
                    r = parseInt(hex.slice(1, 3), 16);
                    g = parseInt(hex.slice(3, 5), 16);
                    b = parseInt(hex.slice(5, 7), 16);
                }
                return { r, g, b, a };
            }

            function colorsMatch(c1, c2) {
                return c1.r === c2.r && c1.g === c2.g && c1.b === c2.b && c1.a === c2.a;
            }

            document.getElementById("pencilBtn").addEventListener("click", () => (tool = "pencil"));
            document.getElementById("lineBtn").addEventListener("click", () => (tool = "line"));
            document.getElementById("rectBtn").addEventListener("click", () => (tool = "rect"));
            document.getElementById("ovalBtn").addEventListener("click", () => (tool = "oval"));
            document.getElementById("fill").addEventListener("click", () => (tool = "fill"));
            document.getElementById("zoomInBtn").addEventListener("click", zoomIn);
            document.getElementById("zoomOutBtn").addEventListener("click", zoomOut);
            document.getElementById("convertBtn").addEventListener("click", convertCanvasToString);
            document.getElementById("clear").addEventListener("click", clear);
            document.getElementById("makeShape").addEventListener("click", convertCanvasToShapeData);
            canvas.addEventListener("mousedown", startDrawing);
            canvas.addEventListener("mousemove", draw);
            canvas.addEventListener("mouseup", endDrawing);
            canvas.addEventListener("mouseout", endDrawing);

            document.addEventListener("keydown", function (event) {
                // Check for Z key with Command (metaKey) or Ctrl key
                if (event.key === "z" && (event.ctrlKey || event.metaKey)) {
                    event.preventDefault(); // Prevent the default undo functionality
                    undoCanvasState(); // Call undo
                }
            });

            function extractCommandsFromUint8Array(inputArray) {
                const commands = [];
                for (let i = 0; i < inputArray.length; i++) {
                    const byte = inputArray[i];
                    // Extract the first command (lower 3 bits)
                    const command1 = byte & 0b111; // 0b111 is 7 in binary, masking the lower 3 bits
                    commands.push(command1);
                    // Extract the second command (next 3 bits)
                    const command2 = (byte >> 3) & 0b111; // Shift right by 3 bits, then mask
                    commands.push(command2);
                    // Extract the third command (next 2 bits)
                    const command3 = (byte >> 6) & 0b11; // Shift right by 3 bits, then mask
                    commands.push(command3);
                }
                return commands;
            }
        </script>
    </body>
</html>
