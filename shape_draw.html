<!DOCTYPE html>
<!-- Apple //e Shape Table Maker -->
<!-- By Rob Terrell -->
<!-- Copyright 2004 Rob Terrell -->
<!-- https://github.com/robterrell/shape_table_maker -->
<html lang="en">
    <head>
        <meta charset="UTF-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1.0" />
        <title>Shape Table Editor</title>
        <style>
            #drawingCanvas {
                border: 1px solid #000;
                cursor: crosshair;
                image-rendering: pixelated;
            }
        </style>
    </head>
    <body>
        <div>
            <p>Bitmap editor for Apple ][+, //e, //c Shape Tables</p>
            <p>Hint: use Command-Z for undo.</p>
            <div>
                <div style="position: absolute; top: 0px; right: 10px">
                    <button id="saveDrawing" onclick="saveDrawing()">Save as...</button>
                    <select id="loadSelect"></select>
                    <br />
                    <button id="downloadShape" style="width: 120px" onclick="downloadShapeAsBinaryFile()">
                        Download Shape</button
                    ><br />
                    <button id="downloadPng" style="width: 120px" onclick="downloadShapeAsPNG()">Download PNG</button
                    ><br />
                    <button id="openBuildPopover" style="width: 120px" popovertarget="builder">
                        Shape Table Builder
                    </button>
                </div>
                <div style="position: absolute; display: grid; left: 0px; top: 80px">
                    <button id="pencilBtn" style="left: 0px; width: 60px; height: 40px">
                        <img
                            src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABwAAAAUCAQAAAA0V5VyAAAA8ElEQVR42tXRvyuEAQCA4Ud3yqEjhYRuonQp6brBZLNYnMGPpIy3G4jdTXfZTDJYhLvFIIa7wqSEC/f9N8ZL99113+jdn+n1DxqTExO5SVWBfRFLGnQlsO5PMUlx7ZtSlTdgFYBZh+58C9SdSghnNYGGNEDKmR8Xdi0YN+PejtamVQUC2wCcKEoBGFK1EcJqTRZW1qOyvlDWaMcmFDUU9EdhcXnvri0ShY268SKnpy3bCp/64Nww0RjHbvVGZzxbEValM+NTVmsZga9OjEsHaJYwjzV7RnQs40PBsrSsTSVvKnp01ZySJ3Wvyo4sdcd+AVHMR3iVEvg+AAAAAElFTkSuQmCC"
                            alt="Pencil"
                            border="0"
                        />
                    </button>
                    <button id="lineBtn" style="left: 0px; width: 60px; height: 40px">
                        <img
                            src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAA8AAAAPCAQAAACR313BAAAAJUlEQVR42mPAA7wZ0nBL+jNcBSrAAfyAkv7DQ9J/oCUxwRZ8kgBRfRSBbVWEfAAAAABJRU5ErkJggg=="
                            alt="Line"
                            border="0"
                        />
                    </button>
                    <button id="rectBtn" style="left: 0px; width: 60px; height: 40px">
                        <img
                            src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABIAAAARCAQAAAB6UzRyAAAAH0lEQVR42mNg+E8EJF4RHkCCopujiqiuiPJooVpSAQC7OnoJqmh4RQAAAABJRU5ErkJggg=="
                            alt="Rectangle"
                            border="0"
                        />
                    </button>
                    <button id="ovalBtn" style="left: 0px; width: 60px; height: 40px">
                        <img
                            src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABoAAAATCAQAAAAkTNWNAAABIklEQVR42p3NvyvmcQDA8ddzT3fndIOLG+4Ww12ZDAYDGSSFgTIoipHCoKSUQSZSiixIj/woKeqZRIpHPI/ioUxf389/YzDoSQ/fvMb38lYipdGodcfyHt04tW1Sm2/KqDDiXBAU7Fg1b1nGS7k1o9obTc4FWUP+KFWl25ZYUZ8SPSJXupTXICuYAqBVLKvG+75bFYwClfLyfvlY2oHIPxgUdEqmVmwedhWkJbWlKMWdFckNC/4SmZNcn6Duk6c9eWlJZRSlGBJ0SKbWkwWoVHCtysfS9kX+A21iR6q976tlwTgAvSI57cqrdySYluJVi5zgUL8apX7qtCH2YMAbP4y5FAQ5m5bMWbTmRCwomvVbGV80m5Bx5lbk3oV90zpUAADPDvpXd0migyQAAAAASUVORK5CYII="
                            alt="Oval"
                            border="0"
                        />
                    </button>
                    <button id="zoomInBtn" style="left: 0px; width: 60px; height: 40px">
                        <img
                            src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABMAAAATCAQAAADYWf5HAAABAklEQVR42o3OL0tDURjA4UfuQC4mRQzqndEgFpNRwa7gn2wzmCxqsWiw6NSZTYaxDzDYil4HS2NomIPzbTTIPbAx5hNOOb+X91XYUdXW1/FiX4lRC2r6Kg5s2XWtp2V1NPpQl4lmVX1Zg6imbhpEU+7kUuJNfRmAIyVAquNEoaoi6lsBcKqh0HY4JtsQzMSPbXBkYCD4fV2CsqAM0LEHEpnMt02ZFKwLZgFe3IxZeixX2NeLMy6kgETTuUJJy7Mpw850zROt+nQvFSXOBK8SiNbkOk5tKFt3rKkrFzwNh6kTDUEQ5M7NW/QmeJQYMSMzB/AXPkhMsORdUPlveGWiZS23Pzo1RYNSBLaAAAAAAElFTkSuQmCC"
                        />
                    </button>
                    <button id="zoomOutBtn" style="left: 0px; width: 60px; height: 40px">
                        <img
                            src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABMAAAATCAQAAADYWf5HAAAA7UlEQVR42o3KsUpCYQBA4S+uEJcmIxoqXRvCxScocC+woNHNwclFWlpqaCkrm50axAcQdKmb4CRSgwT3bWqIH/QK9p31CCo6xuYmuqpyZO3qmWs7d+zUjZmRw+z0oa9AkNfx5ciCnr5NizbcS8SCirmCrNhEXdDRtlrDQDB2YbWy1BbA3Am49B26AkWpIsDEGcgphGJQksoDdN1arSYRVM3kZUWGWoKckRcbljVN7SA49OlBTBBpSr2KLDiSmGgoKyqpGZpKpJ6Xx1jdQOo3iZYde96knkQythRsA/yNjyJr7HuXav93vLbWgZG7H0qYQP0ocnGnAAAAAElFTkSuQmCC"
                        />
                    </button>
                    <button id="clear" style="left: 0px; width: 60px; height: 40px">
                        <img
                            src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABMAAAAXCAQAAABDyLxRAAABF0lEQVR42pXQvyvEcRzH8QfuB9+vlD9AdoWSDBaTTAbFZOEPUAwWpSyKsikuZToZZZDhRsVydWXBlc1foO6uvieldN0nn27xfC3v4dXr9X6/CcyrevPyq7obI3pyZd8AYETFup7cWxY4t0Vg2UZHj05sdHXnsjtPcuhCXVmppyqelKxAn1cTerPrFICaWYwax4ApMA0OHEE/aEqxYBNjjsGZIaRasa2tKFDURqoJOcGWKQjkfCPRDGmtjq0oJhFKNSRRacEX3dJot1BalIFEI7JFaW2ILx1GFqfFl7bEaXkZ8nLi3YS08DV/S5PIVpAhQZzm0w4+7OHdEVI0AZhTkyJmSZVA3q0H5UjXnm1DYNCitUirZvyPHz0/YaPoSZd8AAAAAElFTkSuQmCC"
                        />
                    </button>
                    <button id="fill" style="left: 0px; width: 60px; height: 40px">Fill</button>
                </div>

                <div style="position: absolute; top: 80px; left: 82px">
                    <div style="display: grid">
                        <div class="stack" style="position: relative">
                            <canvas id="drawingCanvas" width="16" height="16" scale="1.0"></canvas>
                            <div
                                id="dragHandle"
                                style="
                                    width: 20px;
                                    height: 20px;
                                    position: absolute;
                                    bottom: -10px;
                                    right: -20px;
                                    cursor: nwse-resize;
                                "
                            >
                                â‡²
                            </div>
                            <div style="position: relative; right: -60px">
                                <span id="sizeText" style="font-size: 9pt; float: right"></span>
                            </div>
                        </div>
                        <!--button id="convertBtn" onclick="convertCanvasToString()">Convert to String</button-->
                        <!--button id="makeShape" onclick="convertCanvasToShapeData">Convert to Shape</button-->
                        <!--button id="describeShape" onclick="describeShape()">Describe Shape</button-->
                        <button id="hexShape" style="width: 120px" onclick="hexDataForShape()">Hex Data</button>
                        <button id="convertBasic" style="width: 120px" onclick="createBasic()">BASIC data</button>
                    </div>
                    <div style="position: absolute">
                        <pre id="output" style="width: 600px"></pre>
                    </div>
                </div>
            </div>
            <dialog popover id="builder" style="position: absolute; left: 60px; top: 40px">
                <select id="buildSelect" multiple style="height: 200px"></select>
                <button id="build" onclick="buildTable()">Build Table</button>
                <button popovertarget="builder" popovertargetaction="hide">Close</button>
            </dialog>
        </div>

        <script>
            const canvas = document.getElementById("drawingCanvas");
            const ctx = canvas.getContext("2d");
            ctx.imageSmoothingEnabled = false;

            ctx.fillStyle = "rgb(255,255,255)";
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            let isDrawing = false;
            let startX = 0;
            let startY = 0;
            let tool = "pencil";
            let scale = 1;
            let scaledWidth = canvas.width;
            let scaledHeight = canvas.height;

            let originX = canvas.width / 2;
            let originY = canvas.height / 2;

            // Create an off-screen canvas for saving the drawing state
            let backupCanvas = document.createElement("canvas");
            let backupCtx = backupCanvas.getContext("2d");
            backupCanvas.width = canvas.width;
            backupCanvas.height = canvas.height;
            backupCtx.imageSmoothingEnabled = false;

            // smaller-sized output canvas, to eliminate aliasing
            let outputCanvas = document.createElement("canvas");
            let outputCtx = backupCanvas.getContext("2d");
            outputCtx.imageSmoothingEnabled = false;
            outputCanvas.width = canvas.width;
            outputCanvas.height = canvas.height;

            // let overlayCanvas = document.createElement("canvas");
            // let overlayCtx = overlayCanvas.getContext("2d");
            // overlayCanvas.width = canvas.width * 32;
            // overlayCanvas.height = canvas.height * 32;

            clear();
            zoomIn();
            zoomIn();
            zoomIn();
            zoomIn();

            function resizeCanvas(w, h) {
                if (h == null) {
                    h = w;
                }
                // save the current drawing, to blit after the resize
                backupCtx.drawImage(canvas, 0, 0);

                canvas.width = w;
                canvas.height = h;
                outputCanvas.width = w;
                outputCanvas.height = h;

                ctx.clearRect(0, 0, canvas.width, canvas.height);
                ctx.fillStyle = "rgba(255,255,255,255)";
                ctx.fillRect(0, 0, canvas.width, canvas.height);

                // blit the backup back onto the drawing canvas
                ctx.drawImage(backupCanvas, 0, 0);

                backupCanvas.width = w;
                backupCanvas.height = h;

                backupCtx.clearRect(0, 0, canvas.width, canvas.height);
                backupCtx.fillStyle = "rgba(255,255,255,255)";
                backupCtx.fillRect(0, 0, canvas.width, canvas.height);

                updateCanvasScale();
            }

            // function drawGrid() {
            //     overlayCanvas.style.width = canvas.width;
            //     overlayCanvas.style.height = canvas.height;
            //     overlayCtx.fillStyle = "rgba(255,255,255,255)";
            //     overlayCtx.fillRect(0, 0, overlayCanvas.width, overlayCanvas.height);
            //     overlayCtx.strokeStyle = "rgba(0,0,0,0)";
            //     console.log("scale", scale);
            //     for (var x = 0; x < overlayCanvas.width; x += scale) {
            //         overlayCtx.moveTo(x, 0);
            //         overlayCtx.lineTo(x, overlayCanvas.height);
            //         overlayCtx.moveTo(0, x);
            //         overlayCtx.lineTo(x, overlayCanvas.width);
            //     }
            // plot the origin
            //ctx.fillStyle = "rgb(255,0,0)";
            //ctx.fillRect(originX, originY, 1, 1);
            // }

            function startDrawing(e) {
                const [x, y] = adjustCoordinates(e);
                if (e.altKey) {
                    originX = x;
                    originY = y;
                    return;
                }
                saveCanvasState(canvas);
                isDrawing = true;
                startX = x;
                startY = y;
                // Get the image data for the pixel under the cursor
                const pixel = ctx.getImageData(x, y, 1, 1).data;
                // Check if the pixel is black (assuming full opacity for simplicity)
                const isBlack = pixel[0] === 0 || pixel[1] === 0 || pixel[2] === 0; // || pixel[3] === 0;

                //console.log("isBlack", isBlack, pixel[0], pixel[1], pixel[2]);
                if (tool === "pencil") {
                    // Set the drawing color based on the pixel color
                    ctx.fillStyle = isBlack ? "rgb(255,255,255)" : "rgb(0,0,0)";
                    ctx.fillRect(x, y, 1, 1);
                }

                if (tool === "fill") {
                    floodFill(x, y, "000");
                }
            }

            function draw(e) {
                if (!isDrawing) return;
                const [x, y] = adjustCoordinates(e);
                switch (tool) {
                    case "pencil":
                        ctx.fillRect(x, y, 1, 1);
                        break;
                    case "line":
                    case "rect":
                    case "oval":
                        redrawCanvas();
                        if (tool === "line") {
                            let endX = x,
                                endY = y;
                            if (e.shiftKey) {
                                const deltaX = Math.abs(endX - startX);
                                const deltaY = Math.abs(endY - startY);

                                // Constrain to horizontal or vertical based on which direction has the greatest distance
                                if (deltaX > deltaY) {
                                    endY = startY; // Make horizontal by fixing the Y-coordinate
                                } else {
                                    endX = startX; // Make vertical by fixing the X-coordinate
                                }
                            }
                            drawLineBresenham(ctx, startX, startY, endX, endY);
                        } else if (tool === "rect") {
                            drawLineBresenham(ctx, startX, startY, startX, y);
                            drawLineBresenham(ctx, startX, y, x, y);
                            drawLineBresenham(ctx, x, y, x, startY);
                            drawLineBresenham(ctx, startX, startY, x, startY);
                        } else if (tool === "oval") {
                            drawOvalAliased(ctx, startX, startY, x, y);
                        }
                        break;
                }
            }

            // Function to adjust mouse coordinates based on the zoom level
            function adjustCoordinates(e) {
                const rect = canvas.getBoundingClientRect();
                const x = Math.round((e.clientX - rect.left) / scale);
                const y = Math.round((e.clientY - rect.top) / scale);
                return [x, y];
            }

            function adjustCanvasForPixelArt(canvas) {
                // Determine the device's pixel ratio
                const pixelRatio = window.devicePixelRatio || 1;

                // Original CSS size of the canvas (could be set to your specific needs)
                const cssWidth = canvas.width;
                const cssHeight = canvas.height;

                // Adjust canvas size for high DPI display
                canvas.width = cssWidth * pixelRatio;
                canvas.height = cssHeight * pixelRatio;

                // Scale the context to compensate for the increased canvas size
                const ctx = canvas.getContext("2d");
                ctx.scale(pixelRatio, pixelRatio);

                // Optional: Disable image smoothing to ensure pixelated graphics
                ctx.imageSmoothingEnabled = false;
            }

            function endDrawing() {
                if (isDrawing) {
                    // When the drawing ends, save the current state to the backup canvas
                    backupCtx.clearRect(0, 0, backupCanvas.width, backupCanvas.height);
                    backupCtx.drawImage(canvas, 0, 0);
                }
                isDrawing = false;
            }

            function redrawCanvas() {
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                // Restore the drawing from the backup canvas
                ctx.drawImage(backupCanvas, 0, 0);
            }

            function drawOvalAliased(ctx, startX, startY, x, y, color = "rgb(0,0,0)") {
                ctx.fillStyle = color;
                // Calculate the center of the oval
                const centerX = (startX + x) / 2;
                const centerY = (startY + y) / 2;

                // Calculate the radii of the oval
                const radiusX = Math.abs(x - startX) / 2;
                const radiusY = Math.abs(y - startY) / 2;

                let xPos, yPos;

                // Drawing the oval
                for (let angle = 0; angle < Math.PI * 2; angle += 0.01) {
                    xPos = centerX + radiusX * Math.cos(angle);
                    yPos = centerY + radiusY * Math.sin(angle);
                    ctx.fillRect(Math.round(xPos), Math.round(yPos), 1, 1);
                }
            }

            function zoomIn() {
                scale *= 2;
                updateCanvasScale();
            }

            function zoomOut() {
                scale /= 2;
                updateCanvasScale();
            }

            function updateCanvasScale() {
                scaledWidth = canvas.width * scale;
                scaledHeight = canvas.height * scale;
                canvas.style.width = `${scaledWidth}px`;
                canvas.style.height = `${scaledHeight}px`;
                // overlayCanvas.style.width = "${scaledWidth}px";
                // overlayCanvas.style.height = "${scaledHeight}px";
                /*                     <canvas
                   id="overlayCanvas"
                   width="16"
                   height="16"
                   scale="2.0"
                   style="position: absolute; left: 0; top: 0; z-index: 99"
               ></canvas>
               */
            }

            function clear() {
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                ctx.fillStyle = "rgba(255,255,255,255)";
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                backupCtx.clearRect(0, 0, canvas.width, canvas.height);
                backupCtx.fillStyle = "rgba(255,255,255,255)";
                backupCtx.fillRect(0, 0, canvas.width, canvas.height);
            }

            function drawLineBresenham(ctx, x0, y0, x1, y1, color = "rgb(0,0,0)") {
                ctx.fillStyle = color;
                let dx = Math.abs(x1 - x0),
                    sx = x0 < x1 ? 1 : -1;
                let dy = -Math.abs(y1 - y0),
                    sy = y0 < y1 ? 1 : -1;
                let err = dx + dy,
                    e2;

                while (true) {
                    ctx.fillRect(x0, y0, 1, 1); // Draw pixel at (x0, y0)
                    if (x0 === x1 && y0 === y1) break;
                    e2 = 2 * err;
                    if (e2 >= dy) {
                        err += dy;
                        x0 += sx;
                    }
                    if (e2 <= dx) {
                        err += dx;
                        y0 += sy;
                    }
                }
            }

            function convertCanvasToString() {
                outputCtx.drawImage(
                    canvas,
                    0,
                    0,
                    canvas.width,
                    canvas.height,
                    0,
                    0,
                    outputCanvas.width,
                    outputCanvas.height
                );

                const imageData = outputCtx.getImageData(0, 0, outputCanvas.width, outputCanvas.height);
                const pixels = imageData.data;
                const width = imageData.width;
                const height = imageData.height;
                let resultString = "";

                for (let y = 0; y < height; y++) {
                    for (let x = 0; x < width; x++) {
                        const index = (y * width + x) * 4; // Calculate index within the image data array
                        const r = pixels[index]; // red value of the pixel
                        const g = pixels[index + 1]; // green value of the pixel
                        const b = pixels[index + 2]; // blue value of the pixel
                        resultString += r == 0 ? "#" : "."; // Append '#' for drawn pixels and '.' for empty
                        //console.log(r, g, b);
                    }
                    resultString += "\n"; // New line at the end of each row
                }
                document.getElementById("output").textContent = resultString;
                return resultString;
            }

            function convertCanvasToShapeData(context) {
                const move_up = 0b000;
                const move_right = 0b001;
                const move_down = 0b010;
                const move_left = 0b011;
                const plot_up = 0b100;
                const plot_right = 0b101;
                const plot_down = 0b110;
                const plot_left = 0b111;

                if (context == null) {
                    context = ctx;
                }

                console.log(
                    "context.canvas.width:",
                    context.canvas.width,
                    "context.canvas.context.canvas.height",
                    context.canvas.height
                );
                const imageData = context.getImageData(0, 0, context.canvas.width, context.canvas.height);
                const pixels = imageData.data;
                const width = imageData.width;
                const height = imageData.height;
                let resultString = "";

                console.log("convertCanvasToShapeData: ", width, height);
                let commands = [];
                let y = 0;
                while (y < height) {
                    //if entire row is empty, skip
                    let rowIsEmpty = true;
                    for (let x = 0; x < width; x++) {
                        const index = (y * width + x) * 4; // Calculate index within the image data array
                        const r = pixels[index]; // red value of the pixel
                        if (r == 0) {
                            rowIsEmpty = false;
                        }
                    }
                    if (rowIsEmpty) {
                        //console.log("row " + y + " is empty");
                        commands.push(move_down);
                        y = y + 1;
                        continue;
                    }
                    if (y >= height) break;

                    for (let x = 0; x < width; x++) {
                        const index = (y * width + x) * 4; // Calculate index within the image data array
                        const r = pixels[index]; // red value of the pixel
                        const endOfRow = x == width - 1;
                        if (r == 0) {
                            if (endOfRow) {
                                commands.push(plot_down);
                            } else {
                                commands.push(plot_right);
                            }
                        } else {
                            if (endOfRow) {
                                commands.push(move_down);
                            } else {
                                commands.push(move_right);
                            }
                        }
                        //console.log(x, y, r, intToVectorName(commands[commands.length - 1]));
                    }

                    y = y + 1;
                    if (y >= height) break;

                    // next row, from right to left
                    for (let x = width - 1; x >= 0; x--) {
                        const index = (y * width + x) * 4; // Calculate index within the image data array
                        const r = pixels[index]; // red value of the pixel
                        const startOfRow = x == 0;
                        if (r == 0) {
                            if (startOfRow) {
                                commands.push(plot_down);
                            } else {
                                commands.push(plot_left);
                            }
                        } else {
                            if (startOfRow) {
                                commands.push(move_down);
                            } else {
                                commands.push(move_left);
                            }
                        }
                        //console.log(x, y, r, intToVectorName(commands[commands.length - 1]));
                    }
                    y = y + 1;
                }
                commands.push(0);
                var out = chunk(commands, width + 2);
                document.getElementById("output").textContent = out.join("\n");
                return commands;
            }

            const chunk = (arr, size) =>
                Array.from({ length: Math.ceil(arr.length / size) }, (v, i) => arr.slice(i * size, i * size + size));

            // function packCommands(commands) {
            //     // take an array of commands (ints 0-7) and pack them into the top and bottom of a byte
            //     // first three bits = first command, second three bits = second command
            //     // two high bits = left both zero
            //     var bytes = new Uint8Array(width * height + 6);
            //     bytes[0] = 1; // number of shapes
            //     bytes[1] = 0; // unused
            //     bytes[2] = 4; // offset to shape 1 (low order byte)
            //     bytes[3] = 0; // offset to shape 1 (high oder byte)
            //     // index 4 is the start of the shape data
            //     var index = 4;
            //     for (var i = 0; i < commands.length; i += 2) {
            //         var c1 = commands[i];
            //         // TODO: handle case where this gives an error
            //         var c2 = commands[i + 1];
            //         bytes[4 + i] = (c2 << 3) | c1;
            //         console.log(c2, c1, bytes[4 + i]);
            //     }
            //     console.log(bytes);
            //     return bytes;
            // }

            function loadImageAsync(imageUrl) {
                return new Promise((resolve, reject) => {
                    const img = new Image();
                    img.onload = () => resolve(img);
                    img.onerror = (error) => reject(error);
                    img.src = imageUrl;
                });
            }

            async function buildTable() {
                let options = document.getElementById("buildSelect").options;
                let shapes = [];
                for (i in options) {
                    let o = options[i];
                    if (o.selected) {
                        let name = o.value;
                        let savedDataUrl = localStorage.getItem(name);
                        if (savedDataUrl == null) continue;
                        //let img = new Image();
                        //img.src = savedDataUrl;
                        let img = await loadImageAsync(savedDataUrl);
                        let width = img.width;
                        let height = img.height;

                        // outputCanvas.width = width;
                        // outputCanvas.height = height;
                        // outputCtx.clearRect(0, 0, width, height);
                        // outputCtx.drawImage(img, 0, 0, width, height);
                        // for some reason outputCtx is sometimes the wrong size -- maybe a side effet
                        // of using async? so we'll make a new one for each

                        let _canvas = document.createElement("canvas");
                        _canvas.width = width;
                        _canvas.height = height;
                        let _ctx = _canvas.getContext("2d");
                        _ctx.clearRect(0, 0, width, height);
                        _ctx.drawImage(img, 0, 0, width, height);

                        let shape = packIntegersToUint8Array(new Uint8Array(convertCanvasToShapeData(_ctx)), false);
                        shapes.push(shape);
                        // TODO: are we leaking the canvas?
                    }
                }
                let data = assembleTableFromShapes(shapes);

                // Create a new Blob object using the Uint8Array's data
                const blob = new Blob([data], { type: "application/octet-stream" });

                // Create an object URL for the blob
                const url = URL.createObjectURL(blob);

                // Create a temporary anchor element and set its href to the blob URL
                const a = document.createElement("a");
                a.href = url;
                let filename = prompt("Save as...");
                if (filename == null) return;

                a.download = filename; // Set the filename for the download

                // Append the anchor to the document, trigger a click on it, and then remove it
                document.body.appendChild(a); // Append to the body (or any other existing element)
                a.click(); // Trigger the download

                // Clean up by revoking the object URL and removing the anchor element
                URL.revokeObjectURL(url);
                document.body.removeChild(a);
            }

            function assembleTableFromShapes(shapesArray) {
                // the argument should be an array of arrays (i.e. ints) or of the type bytearray
                // ideally, these should be sprite tables already packed with no headers
                const num = shapesArray.length;
                if (num > 255) {
                    throw "Too many shapes for shape table";
                }
                let offsets = [];
                const dataSize = shapesArray.reduce((acc, curr) => acc + curr.length, 0);
                const headerSize = 2 + shapesArray.length * 2;
                const packedArray = new Uint8Array(headerSize + dataSize + 1);
                packedArray[0] = num; // number of shapes
                packedArray[1] = 0; // unused
                let nextShapeOffset = 2 + num * 2;
                //
                // create header and keep the offsets
                //
                for (var i = 0; i < num; i++) {
                    offsets[i] = nextShapeOffset;
                    let lowByte = nextShapeOffset & 0xff;
                    let highByte = (nextShapeOffset >> 8) & 0xff;
                    packedArray[2 + i * 2] = lowByte; // offset to shape 1 (low order byte)
                    packedArray[3 + i * 2] = highByte; // offset to shape 1 (high oder byte)
                    console.log("shape", i, "offset:", nextShapeOffset, "(" + lowByte + "," + highByte + ")");
                    nextShapeOffset = nextShapeOffset + shapesArray[i].length;
                }
                //
                // write the shapes at their offsets
                //
                for (var i = 0; i < num; i++) {
                    let shape = shapesArray[i];
                    let offset = offsets[i];
                    for (var c = 0; c < shape.length; c++) {
                        packedArray[offset + c] = shape[c];
                    }
                }
                // the table ends with a zero byte

                packedArray[packedArray.length - 1] = 0;
                return packedArray;
            }

            function packIntegersToUint8Array(integers, header = true) {
                // Each element needs 3 bits, so two elements make a byte.
                // If there's an odd number of integers, the last one still requires a full byte.
                // ignoring the special case of using the two high bits for now
                const size = Math.ceil(integers.length / 2) + 4;
                const packedArray = new Uint8Array(size);
                let offset = 0;
                if (header) {
                    packedArray[0] = 1; // number of shapes
                    packedArray[1] = 0; // unused
                    packedArray[2] = 4; // offset to shape 1 (low order byte)
                    packedArray[3] = 0; // offset to shape 1 (high oder byte)
                    offset = 4;
                }
                integers.forEach((value, index) => {
                    // Calculate which byte this value should go into
                    const byteIndex = offset + Math.floor(index / 2);

                    if (value === 0) {
                        packedArray[byteIndex] = 0;
                        return;
                    }

                    // Ensure the value is within the expected range
                    if (value < 1 || value > 7) {
                        throw new RangeError("Integer values must be in the range of 1-7.");
                    }

                    if (index % 2 === 0) {
                        // If it's an even index (or the first of a pair),
                        // add the value to the byte without shifting (occupies the lowest 3 bits).
                        packedArray[byteIndex] = value;
                    } else {
                        // If it's an odd index (or the second of a pair),
                        // shift the value left by 3 bits and add it to the byte.
                        packedArray[byteIndex] |= value << 3;
                    }

                    // there's a further space optimization possible with the
                    // two high bits... I am skipping this for now.
                });

                return packedArray;
            }

            /*  Sample Program that loads the shape table:
              5   X = 0: POKE 232,0: POKE 233,32
              10  READ D: IF D < 0 THEN  GOTO 100
              20  POKE 16384 + X, INT (D): X = X + 1: GOTO 10
             100  HGR : HCOLOR= 3: SCALE= 1: ROT= 0: DRAW 1 AT 30,50
            */

            function createBasic() {
                let array = packIntegersToUint8Array(convertCanvasToShapeData());
                let result = "1000 REM SHAPE TABLE\n";
                result += "1010 DATA ";
                lineNum = 1010;
                array.forEach((byte, index) => {
                    // Convert byte to hex format, padded with a leading zero if necessary
                    //let val = byte.toString(16).padStart(2, "0").toUpperCase();
                    let val = byte.toString(10);
                    // Add the hex byte to the result string
                    result += val;
                    // Determine if a comma should be added
                    let isLastByteInLine = (index + 1) % 8 === 0;
                    let isLastByteInArray = index === array.length - 1;

                    // Add a comma if it's not the last byte in the line or the last byte in the array
                    if (!isLastByteInLine && !isLastByteInArray) {
                        result += ",";
                    }

                    // Add a newline after every 8 bytes, except after the last byte
                    if (isLastByteInLine && !isLastByteInArray) {
                        //let lineNum = 1020 + index * 10;
                        result += "\n" + ++lineNum + " DATA ";
                    }
                });
                result += "\n" + ++lineNum + " DATA -1";
                document.getElementById("output").textContent = result;
                return result;
            }

            function intToVectorName(i) {
                let result = "";
                switch (i) {
                    case 0:
                        result += "move up";
                        break;
                    case 1:
                        result += "move right";
                        break;
                    case 2:
                        result += "move down";
                        break;
                    case 3:
                        result += "move left";
                        break;
                    case 4:
                        result += "plot up";
                        break;
                    case 5:
                        result += "plot right";
                        break;
                    case 6:
                        result += "plot down";
                        break;
                    case 7:
                        result += "plot left";
                        break;
                }
                return result;
            }

            function describeShape() {
                let commands = convertCanvasToShapeData();
                let result = "";
                for (index in commands) {
                    let command = commands[index];
                    result += intToVectorName(command) + "\n";
                }
                document.getElementById("output").textContent = result;
                return result;
            }

            function hexDataForShape() {
                let commands = convertCanvasToShapeData();
                let result = "";
                for (index in commands) {
                    let command = commands[index];
                    result += command.toString(16).padStart(2, "0") + " ";
                }

                document.getElementById("output").textContent = "01 00 04 00\n" + chunk(result, 33).join("\n");
                return result;
            }

            function annotateShape() {
                let commands = convertCanvasToShapeData();
                let result = "";
                let temp = "";
                let i = 0;
                for (index in commands) {
                    let command = commands[index];
                    if (command == 2) {
                        i++;
                    }
                    result += i++ + intToVectorName(command) + "\n";
                }
                document.getElementById("output").textContent = result;
                return result;
            }

            // Undo support

            let canvasStates = [];

            function saveCanvasState(canvas) {
                const dataUrl = canvas.toDataURL();
                canvasStates.push(dataUrl);
            }

            function undoCanvasState() {
                if (canvasStates.length <= 0) return;

                const previousState = canvasStates.pop();
                const img = new Image();
                img.onload = () => {
                    ctx.clearRect(0, 0, canvas.width, canvas.height);
                    ctx.drawImage(img, 0, 0, canvas.width, canvas.height);
                    backupCtx.clearRect(0, 0, backupCanvas.width, backupCanvas.height);
                    backupCtx.drawImage(img, 0, 0, backupCanvas.width, backupCanvas.height);
                };
                img.src = previousState;
            }

            // Loading and saving to local storage

            function loadDrawingOntoCanvas(name) {
                let savedDataUrl = localStorage.getItem(name);
                if (savedDataUrl) {
                    let img = new Image();
                    img.src = savedDataUrl;
                    img.onload = function () {
                        // Display the image on the page or draw it on another canvas
                        resizeCanvas(img.width, img.height);
                        ctx.drawImage(img, 0, 0, img.width, img.height);
                        backupCtx.drawImage(img, 0, 0, img.width, img.height);
                        canvasStates = [];
                        document.title = name;
                    };
                }
            }

            function saveDrawing() {
                var name = prompt("Name to save as");
                if (name != null) {
                    saveDrawingToLocalStorage(name);
                }
            }

            function saveDrawingToLocalStorage(name) {
                const dataUrl = canvas.toDataURL();
                localStorage.setItem(name, dataUrl);
                showSelectMenuAndLoadDrawing();
                document.title = name;
            }

            function showSelectMenuAndLoadDrawing() {
                //const select = document.createElement('select');
                let select = document.getElementById("loadSelect");
                let bs = document.getElementById("buildSelect");
                select.innerHTML = "<option>Load...</option>";
                bs.innerHTML = "";
                Object.keys(localStorage).forEach((key) => {
                    select.innerHTML += `<option value="${key}">${key}</option>`;
                    bs.innerHTML += `<option value="${key}">${key}</option>`;
                });

                select.addEventListener("change", function () {
                    if (this.value !== "Load...") {
                        loadDrawingOntoCanvas(this.value);
                        this.options[0].selected = true;
                    }
                });
            }
            showSelectMenuAndLoadDrawing();

            // for debugging, download as encoded text
            function downloadShapeAsTextFile() {
                let filename = "";
                const select = document.getElementById("loadSelect");
                if (select.value == "Load...") {
                    filename = prompt("Save as...");
                    if (filename == null) return;
                } else {
                    filename = select.value;
                }
                filename += ".txt";

                const dataUrl = canvas.toDataURL();
                const blob = new Blob([dataUrl], { type: "text/plain" });

                // Create an object URL for the blob
                const url = URL.createObjectURL(blob);

                // Create a temporary anchor element and set its href to the blob URL
                const a = document.createElement("a");
                a.href = url;
                a.download = filename; // Set the filename for the download

                // Append the anchor to the document, trigger a click on it, and then remove it
                document.body.appendChild(a); // Append to the body (or any other existing element)
                a.click(); // Trigger the download

                // Clean up by revoking the object URL and removing the anchor element
                URL.revokeObjectURL(url);
                document.body.removeChild(a);
            }

            // for debugging, download a PNG
            function downloadShapeAsPNG() {
                let filename = "";
                const select = document.getElementById("loadSelect");
                if (select.value == "Load...") {
                    filename = prompt("Save as...");
                    if (filename == null) return;
                } else {
                    filename = select.value;
                }
                filename += ".png";

                const dataUrl = canvas.toDataURL("image/png");

                let downloadLink = document.createElement("a");
                downloadLink.href = dataUrl;
                downloadLink.download = filename;

                // Append the anchor to the document body temporarily
                document.body.appendChild(downloadLink);

                // Trigger a click on the anchor to start the download
                downloadLink.click();

                // Clean up by removing the temporary anchor element
                document.body.removeChild(downloadLink);
            }

            function downloadShapeAsBinaryFile() {
                let filename = "";
                const select = document.getElementById("loadSelect");
                if (select.value == "Load...") {
                    filename = prompt("Save as...");
                    if (filename == null) return;
                } else {
                    filename = select.value;
                    select.value = 0;
                }
                filename += ".bin";

                let data = convertCanvasToShapeData();
                let uint8Array = packIntegersToUint8Array(new Uint8Array(data));
                // Create a new Blob object using the Uint8Array's data
                const blob = new Blob([uint8Array], { type: "application/octet-stream" });

                // Create an object URL for the blob
                const url = URL.createObjectURL(blob);

                // Create a temporary anchor element and set its href to the blob URL
                const a = document.createElement("a");
                a.href = url;
                a.download = filename; // Set the filename for the download

                // Append the anchor to the document, trigger a click on it, and then remove it
                document.body.appendChild(a); // Append to the body (or any other existing element)
                a.click(); // Trigger the download

                // Clean up by revoking the object URL and removing the anchor element
                URL.revokeObjectURL(url);
                document.body.removeChild(a);
            }

            // flood fill algorithm courtesy of chatGPT
            function floodFill(startX, startY, fillColor) {
                const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
                const data = imageData.data;
                const width = imageData.width;
                const targetColor = getColorAtPixel(data, startX, startY, width);
                const newColor = hexToRgba(fillColor);

                // Check if the target color is the same as the new color
                if (colorsMatch(targetColor, newColor)) {
                    return; // No need to fill
                }

                function fill(x, y) {
                    // Check bounds
                    if (x < 0 || y < 0 || x >= imageData.width || y >= imageData.height) {
                        return;
                    }

                    const currentColor = getColorAtPixel(data, x, y, width);

                    // If the current pixel's color is not the target color, or already the new color, return
                    if (!colorsMatch(currentColor, targetColor) || colorsMatch(currentColor, newColor)) {
                        return;
                    }

                    // Set the pixel to the new color
                    setColorAtPixel(data, x, y, newColor, width);

                    // Recursive calls for adjacent pixels
                    fill(x + 1, y); // East
                    fill(x - 1, y); // West
                    fill(x, y + 1); // South
                    fill(x, y - 1); // North
                }

                fill(startX, startY);

                ctx.putImageData(imageData, 0, 0);
            }

            // Helper functions
            function getColorAtPixel(data, x, y, width) {
                const index = (y * width + x) * 4;
                return {
                    r: data[index],
                    g: data[index + 1],
                    b: data[index + 2],
                    a: data[index + 3],
                };
            }

            function setColorAtPixel(data, x, y, color, width) {
                const index = (y * width + x) * 4;
                data[index] = color.r;
                data[index + 1] = color.g;
                data[index + 2] = color.b;
                data[index + 3] = color.a;
            }

            function hexToRgba(hex) {
                var r = 0,
                    g = 0,
                    b = 0,
                    a = 255; // Default is opaque black
                if (hex.length == 7) {
                    r = parseInt(hex.slice(1, 3), 16);
                    g = parseInt(hex.slice(3, 5), 16);
                    b = parseInt(hex.slice(5, 7), 16);
                }
                return { r, g, b, a };
            }

            function colorsMatch(c1, c2) {
                return c1.r === c2.r && c1.g === c2.g && c1.b === c2.b && c1.a === c2.a;
            }

            // set up event listeners for tools and canvas
            document.getElementById("pencilBtn").addEventListener("click", () => (tool = "pencil"));
            document.getElementById("lineBtn").addEventListener("click", () => (tool = "line"));
            document.getElementById("rectBtn").addEventListener("click", () => (tool = "rect"));
            document.getElementById("ovalBtn").addEventListener("click", () => (tool = "oval"));
            document.getElementById("fill").addEventListener("click", () => (tool = "fill"));
            document.getElementById("zoomInBtn").addEventListener("click", zoomIn);
            document.getElementById("zoomOutBtn").addEventListener("click", zoomOut);
            document.getElementById("clear").addEventListener("click", clear);
            canvas.addEventListener("mousedown", startDrawing);
            canvas.addEventListener("mousemove", draw);
            canvas.addEventListener("mouseup", endDrawing);
            canvas.addEventListener("mouseout", endDrawing);

            document.addEventListener("keydown", function (event) {
                // Check for Z key with Command (metaKey) or Ctrl key
                if (event.key === "z" && (event.ctrlKey || event.metaKey)) {
                    event.preventDefault(); // Prevent the default undo functionality
                    undoCanvasState(); // Call undo
                }
            });

            // Drag to resize
            let isDragging = false;
            const dragHandle = document.getElementById("dragHandle");
            let dragStartX, dragStartY, startWidth, startHeight;

            dragHandle.addEventListener("mousedown", function (e) {
                isDragging = true;
                dragStartX = e.clientX;
                dragStartY = e.clientY;
                startWidth = canvas.offsetWidth;
                startHeight = canvas.offsetHeight;
                e.preventDefault();
            });

            document.addEventListener("mousemove", function (e) {
                if (!isDragging) return;
                let newWidth = startWidth + (e.clientX - dragStartX);
                let newHeight = startHeight + (e.clientY - dragStartY);

                // Optionally, keep the canvas square
                if (e.shiftKey) {
                    let newSize = Math.floor(Math.max(newWidth, newHeight) / scale);
                    resizeCanvas(newSize);
                    document.getElementById("sizeText").textContent = "(" + newSize + " x " + newSize + ")";
                } else {
                    var w = Math.floor(newWidth / scale);
                    let h = Math.floor(newHeight / scale);
                    resizeCanvas(w, h);
                    document.getElementById("sizeText").textContent = "(" + w + " x " + h + ")";
                }
            });

            document.addEventListener("mouseup", function (e) {
                if (isDragging) {
                    isDragging = false;
                    updateCanvasScale(); // Assuming this function updates the display based on the new canvas size
                }
            });

            // for the future: load a shape file and render it as a bitmap
            function extractCommandsFromUint8Array(inputArray) {
                const commands = [];
                for (let i = 0; i < inputArray.length; i++) {
                    const byte = inputArray[i];
                    // Extract the first command (lower 3 bits)
                    const command1 = byte & 0b111; // 0b111 is 7 in binary, masking the lower 3 bits
                    commands.push(command1);
                    // Extract the second command (next 3 bits)
                    const command2 = (byte >> 3) & 0b111; // Shift right by 3 bits, then mask
                    commands.push(command2);
                    // Extract the third command (next 2 bits)
                    const command3 = (byte >> 6) & 0b11; // Shift right by 3 bits, then mask
                    commands.push(command3);
                }
                return commands;
            }
        </script>
    </body>
</html>
